### DI와 Service Locater의 궁극적 목적 : 메인영역에서 객체들을 연결해주기 위함

**소프트웨어**
- **메인 영역 :** 어플리케이션이 동작하도록 각 객체들을 연결해주는 영역
- **애플리케이션 영역 :** 고수준 정책, 저수준 구현을 포함하는 영역
- 애플리케이션 실행

### 메인의 역할
1. 애플리케이션에서 사용할 객체 생성
2. 각 객체 간의 의존 관계 설정
⇒ 애플리케이션에서 사용할 하위 수준의 모듈을 수정하고 싶다면 메인 영역을 수정해야
⇒ 메인 영역에서 모듈이나 객체를 수정하는 DI, 서비스 로케이터 등장

# Dependence Injection (의존성 주입)
### 의미
필요한 객체를 직접 생성하거나 찾지 않고 외부에서 넣어주는 방식
> Dependency injection is **a programming technique that makes a class independent of its dependencies**.
> 
소프트웨어 엔지니어링에서 의존성 주입은 하나의 객체가 다른 객체의 의존성을 제공하는 테크닉이다. "의존성"은 예를 들어 서비스로 사용할 수 있는 객체이다. 클라이언트가 어떤 서비스를 사용할 것인지 지정하는 대신, 클라이언트에게 무슨 서비스를 사용할 것인지를 말해주는 것이다.

용어 설명
- “주입” : 의존성(서비스)을 사용하려는 객체(클라이언트)로 전달하는 것
- 서비스 : 클라이언트의 상태의 일부
- 클라이언트가 서비스를 구축하거나 찾는 것을 허용하는 대신 클라이언트에서 서비스를 전달

**이유**
- 느슨한 결합
- 의존관계 역전 원칙과 단일 책임 원칙을 따르도록
    - **의존관계 역전 원칙(DIP)** : 소프트웨어 모듈을 분리 (객체 지향 프로그래밍) → 상위 모듈이 하위 모듈(세부 사항)에 의존하지 않도록 함, 추상화(**추상화**(abstraction)는 복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념 또는 기능을 간추려 내는 것)에 의존해야
    - **단일 책임 원칙 (Single Responsibility Principle)** : 모든 클래스는 하나의 책임만을 가지며, 클래스는 그 책임을 완전히 캡슐화(객체의 속성(data fields)과 행위(메서드, methods)를 하나로 묶고,실제 구현 내용 일부를 내부에 감추어 은닉한다)해야 함
- 클라이언트의 생성에 대한 의존성을 클라이언트의 행위로 부터 분리 (==객체의 생성과 사용의 관심을 분리) → 가독성과 코드 재사용을 높여줌

**이런 문제를 해결?**
- 어떻게 애플리케이션이나 클래스가 객체의 생성 방식과 독립적일 수 있는가?
- 어떻게 객체의 생성 방식을 분리된 구성 파일에서 지정할 수 있는가?
- 어떻게 애플리케이션이 다른 구성을 지원할 수 있는가?

특징
- 광범위한 역제어 테크닉의 한 형태

### 전제
1. 사용될 **서비스** 객체 : 자동차
2. 사용하는 서비스에 의존하는 **클라이언트** 객체 : 운전자
3. 클라이언트의 서비스 사용 방법을 정의하는 인터페이스 
    1. 클라이언트가 의존성으로 예상하는 타입 
4. 서비스를 생성하고 클라이언트로 주입하는 책임을 갖는 주입자

### 의존성?
어떤 클래스 A에서 특정 함수 B가 호출되기 위해서는 클래스 C를 필요로 한다 ⇒ A 클래스는 C 클래스의 **의존성**을 가진다

문제점 
    코드 재활용성이 떨어지고
    클래스 C가 수정되었을 때 A도 수정해줘야 하는 문제 발생
    ⇒ 결합도(coupling)이 높아짐 

### 해야 하는 이유
1. Unit Test가 용이해짐 
    1. 단위 테스트는 어떤 클래스의 하나의 단위 기능을 테스트 하는데 초점이 맞춰져 있다
2. 코드의 재활용성이 높아짐
3. 객체 간의 의존성(종속성)을 줄이거나 없앨 수 있음
4. 객체 간의 결합도를 낮추면서 유연한 코드를 작성할 수 있다 

### 방법
DI 구현 자체는 매우 간단한데, 사용할 객체를 주입받을 수 있는 방법을 제공하면 된다. (그리고 이는 우리가 자주 보는 생성자 방식이다.)
```java
class Coffee {...} // interface로 설계할 수도 있다

// Coffee 클래스를 상속
class Cappuccino extends Coffee {...}
class Americano extends Coffee {...}

// Programmer.java
class Programmer {
    private Coffee coffee;

    public Programmer() {
    	this.coffee = new Cappuccino(); // 직접 수정
        // 또는 
        this.coffee = new Americano(); // 직접 수정
    }
    
    ...
}

// Programmer.java
class Programmer {
    private Coffee coffee;

    // 그 날 마실 커피를 고를 수 있게된 개발자
    public Programmer(Coffee coffee) {
    	this.coffee = coffee;
    }
    
    public startProgramming() {
    	this.coffee.drink();
        ...
    }
}
```

필요한(의존하는) 클래스를 직접 생성하지 않고 주입해 줌으로써 
객체간의 결합도를 줄이고
유연한 코드를 작성할 수 있다
⇒ 의존성 주입은 필요한 객체를 직접 생성하는 것이 아닌 외부로 부터 필요한 객체를 받아서 사용하는 것

### 방식
1. 생성자 방식
    1. 생성자를 통해 전달받은 객체를 필드에 보관한 뒤 메소드에서 사용
2. 설정 메소드 방식
    1. Setter를 이용?
    2. 객체를 생성하는 시점에 필요한 모든 의존 객체를 준비할 수 있고, 생성 시점에 의존 객체가 정상인지 확인할 수 있기

### 참고 사이트
https://velog.io/@wlsdud2194/what-is-di
[https://medium.com/@jang.wangsu/di-dependency-injection-이란-1b12fdefec4f](https://medium.com/@jang.wangsu/di-dependency-injection-%EC%9D%B4%EB%9E%80-1b12fdefec4f)


# Service Locater
### 의미
서비스 로케이터는 어플리케이션에서 필요로 하는 객체를 제공하는 책임을 가짐
로케이터를 통해서 필요한 객체를 직접 찾는 방식

### 사용하는 이유
프로그램 개발 환경이나 사용하는 프레임 워크의 제약으로 인해 DI 패턴을 적용할 수 없는 경우가 있다. 예를 들어, 안드로이드 플랫폼을 개발하는 모바일 앱의 경우 화면을 생성할 때 Activity 클래스를 상속받도록 하는데 이 경우에는 DI처리를 할 수 없다.

### 방법
의존 대상이 되는 객체별로 제공 메소드를 정의하고, 의존 객체가 필요한 코드에서는 ServiceLocator가 제공하는 메소드를 활용해서 알맞은 객체를 의존한 뒤 기능을 수행할 수 있다.
서비스 로케이터가 올바르게 동작하기 위해서는 서비스 로케이터 스스로 어떤 객체를 제공해야할지에 대해서 알고 있어야 한다.

```java
public class ServiceLocator {
	public 작업 get작업() {...}
    public 의존객체 get의존객체() {...}
}
```

메인 영역에서 서비스 로케이터가 제공할 객체를 초기화해준다.
서비스 로케이터는 어플리케이션 영역의 객체에서 직접 접근하기 때문에, 애플리케이션 영역에 위치하게 된다.

### 객체 등록 방식 & 상속 방식
1. 객체 등록 방식
    1. 서비스 로케이터를 생성할 때 사용할 객체를 전달한다.
    2. 서비스 로케이터 인스턴스를 지정하고 참조하기 위한 static 메소드를 제공한다.
    3. 장점 : 구현이 쉽지만
    4. 단점: 서비스 로케이터에 객체를 등록하는 인터페이스가 노출되어 있기 때문에 애플리케이션 영역의 코드에서 얼마든지 의존 객체를 변경할 수 있고, 고수준 모듈에서 저수준 모듈인 구체(concrete) 클래스에 직접 접근하도록 유도할 수 있기 때문에, DIP(의존 역전 원칙)을 어기게 만드는 원인이 된다.
2. 상속 방식
    1. 객체를 구하는 추상 메소드를 제공하는 상위 타입 구현
    2. 상위 타입을 상속받은 하위 타입에서 사용할 객체 설정
    3. 의존 객체를 교체해야할 때, 어플리케이션 영역의 코드 수정 없이 메소드인 영역의 코드만 수정할 수 있다.

### 장점
- 

### 단점
- 인터페이스 분리 원칙을 위반함
    - ⇒ 의존 객체마다 서비스 로케이터를 작성해줘야?
        - 하지만 매번 로케이터를 만들어주는 건 코드 중복이라 피해야 한다
        - ⇒ 제네릭 사용 : 제네릭은 클래스나 메소드에서 사용할 내부 데이터 타입을 컴파일 시에 미리 지정하는 방법
    - 동일 타입의 객체가 다수 필요한 경우, 각 객체별로 제공 메소드를 만들어 주어야 한다.
    - 조건에 따라 서로 다른 객체를 사용해야 한다면 조건에 따라 ServiceLocator의 다른 메소드를 호출하는 코드가 들어가게 되고, OCP를 지키지 못하게 된다.

### 참고 사이트
https://incheol-jung.gitbook.io/docs/study/undefined/di
https://m.blog.naver.com/xlql555/221967170495

## DI 와 서비스 로케이터의 차이점?
- 공통점은 메인 영역에서 객체 생성(DI), 객체 초기화(서비스 로케이터)
- 차이점
    - 서비스 로케이터는 어플리케이션 영역에 위치

## Stream
**실제의 입력이나 출력이 표현된 데이터의 이상화된 흐름**을 의미합니다.
즉, 스트림은 운영체제에 의해 생성되는 가상의 연결 고리를 의미하며, 중간 매개자 역할을 합니다.

### 참고 사이트
http://www.tcpschool.com/java/java_io_stream